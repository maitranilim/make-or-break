<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="Make-or-Break: A relaxing yet chaotic physics simulation where builders and breakers compete. Watch the battle between order and entropy in your browser.">
    <meta name="keywords" content="simulation game, physics, stress relief, builder vs breaker, chaos theory, interactive art">
    <title>Make-or-Break | Interactive Physics Simulation</title>

    <!-- Google AdSense -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4315629123147124" crossorigin="anonymous"></script>

    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Make-or-Break Simulation",
      "description": "An interactive physics simulation demonstrating the balance between creation and destruction.",
      "applicationCategory": "Game",
      "operatingSystem": "Any"
    }
    </script>

    <style>
        /* --- CSS VARIABLES & RESET --- */
        :root {
            --bg-color: #0b0d16;
            --panel-bg: #161a30;
            --text-color: #eaeaf0;
            --text-muted: #888999;
            --accent-red: #ff5c5c;
            --accent-green: #4dff88;
            --accent-blue: #3a7bfd;
            --font-main: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        * { box-sizing: border-box; touch-action: manipulation; -webkit-tap-highlight-color: transparent; }
        
        body {
            margin: 0;
            background: var(--bg-color);
            color: var(--text-color);
            font-family: var(--font-main);
            overflow-x: hidden;
            overflow-y: auto; /* Allow scrolling */
        }

        h1, h2, h3 { margin: 0; font-weight: 700; letter-spacing: -0.02em; }
        p { line-height: 1.6; color: var(--text-muted); }

        /* --- HEADER & CONTROLS --- */
        header {
            height: auto;
            min-height: 80px;
            background: rgba(11, 13, 22, 0.95);
            border-bottom: 1px solid #2a2d40;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            position: sticky;
            top: 0;
            z-index: 100;
            backdrop-filter: blur(10px);
        }

        .controls-group {
            display: flex;
            gap: 20px;
            align-items: center;
            flex: 1;
            flex-wrap: wrap; /* Prevent chopping */
        }

        .slider-container {
            display: flex;
            flex-direction: column;
            gap: 6px;
            min-width: 100px;
            flex-grow: 1;
            max-width: 150px;
        }

        .slider-label {
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
        }

        input[type=range] {
            width: 100%;
            height: 4px;
            background: #333855;
            border-radius: 2px;
            appearance: none;
            outline: none;
            cursor: pointer;
        }
        input[type=range]::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            margin-top: -6px; /* center on track */
        }
        input[type=range]::-webkit-slider-runnable-track { height: 4px; border-radius: 2px; }
        
        /* Thumb Colors */
        #slider-red::-webkit-slider-thumb { background: var(--accent-red); }
        #slider-green::-webkit-slider-thumb { background: var(--accent-green); }
        #slider-time::-webkit-slider-thumb { background: var(--accent-blue); }
        #slider-chaos::-webkit-slider-thumb { background: #e0e0e0; }

        /* Buttons */
        .btn-group { display: flex; align-items: center; gap: 10px; }
        
        button.action-btn {
            background: var(--panel-bg);
            color: var(--text-color);
            border: 1px solid #333855;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 700;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.2s;
            height: 38px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        button.action-btn:hover { background: #232845; border-color: #4d5470; }
        button.action-btn:active { transform: scale(0.96); }

        .icon-btn {
            background: transparent;
            border: none;
            padding: 8px;
            cursor: pointer;
            color: var(--text-muted);
            transition: color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .icon-btn svg { width: 24px; height: 24px; fill: currentColor; }
        .icon-btn:hover { color: var(--text-color); }
        .icon-btn.active { color: var(--accent-blue); }

        /* Toggle Switch for Multi-Mode */
        .toggle-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            font-weight: 700;
            text-transform: uppercase;
            color: var(--text-muted);
            cursor: pointer;
        }
        .toggle-switch {
            width: 36px; height: 20px;
            background: #333855;
            border-radius: 20px;
            position: relative;
            transition: background 0.3s;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px; left: 2px;
            width: 16px; height: 16px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        input[type="checkbox"]:checked + .toggle-switch { background: var(--accent-blue); }
        input[type="checkbox"]:checked + .toggle-switch::after { transform: translateX(16px); }

        /* --- HERO / GAME SECTION --- */
        #hero-section {
            position: relative;
            width: 100%;
            height: 85vh; /* Takes up most of the screen */
            min-height: 500px;
            background: #05060a;
            display: flex;
            flex-direction: column;
            border-bottom: 4px solid #1a1d2e; /* Divider */
        }

        #game-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            display: block;
            box-shadow: 0 0 50px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
        }

        /* --- OVERLAYS --- */
        #overlay-result {
            position: absolute;
            inset: 0;
            background: rgba(11, 13, 22, 0.9);
            backdrop-filter: blur(5px);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 50;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        #timer-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 4rem;
            font-weight: 800;
            color: rgba(255,255,255,0.05);
            pointer-events: none;
            z-index: 5;
        }

        /* --- SEO & FAQ CONTENT SECTION --- */
        #content-section {
            max-width: 900px;
            margin: 0 auto;
            padding: 60px 24px;
            animation: slideUp 0.5s ease-out;
        }
        @keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

        .seo-header { margin-bottom: 40px; text-align: left; }
        .seo-header h2 { font-size: 2.5rem; color: #fff; margin-bottom: 16px; }
        .seo-grid { display: grid; grid-template-columns: 1fr; gap: 40px; }
        
        .info-card {
            background: rgba(255,255,255,0.02);
            border: 1px solid #2a2d40;
            padding: 30px;
            border-radius: 12px;
        }
        .info-card h3 { color: var(--accent-blue); margin-bottom: 12px; font-size: 1.2rem; }
        
        .ad-container {
            width: 100%;
            min-height: 100px;
            background: rgba(255,255,255,0.01);
            border: 1px dashed #333;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 30px 0;
            border-radius: 8px;
            color: #444;
            font-size: 0.9rem;
        }

        /* --- SIDE MENU --- */
        #side-menu {
            position: fixed;
            top: 0; right: -320px;
            width: 300px;
            height: 100%;
            background: #111420;
            border-left: 1px solid #2a2d40;
            z-index: 200;
            transition: right 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            display: flex;
            flex-direction: column;
            box-shadow: -10px 0 30px rgba(0,0,0,0.5);
        }
        #side-menu.open { right: 0; }
        
        .menu-header {
            padding: 20px;
            border-bottom: 1px solid #2a2d40;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .menu-content { padding: 20px; overflow-y: auto; flex: 1; }

        .score-entry {
            display: flex; justify-content: space-between; padding: 10px;
            background: rgba(255,255,255,0.03); border-radius: 4px;
            margin-bottom: 8px; font-size: 12px; border-left: 3px solid transparent;
        }
        .score-entry.win-green { border-left-color: var(--accent-green); }
        .score-entry.win-red { border-left-color: var(--accent-red); }

        /* Responsive */
        @media (min-width: 768px) {
            .seo-grid { grid-template-columns: 1fr 1fr; }
            .full-width-card { grid-column: span 2; }
        }
        @media (max-width: 600px) {
            header { padding: 10px; gap: 10px; }
            .controls-group { width: 100%; gap: 10px; justify-content: space-between; }
            .slider-container { min-width: 45%; max-width: 48%; }
            #timer-display { font-size: 2.5rem; top: 10px; }
            .btn-group { width: 100%; justify-content: space-between; margin-top: 5px; }
        }
    </style>
</head>
<body>

<!-- HEADER -->
<header>
    <div class="controls-group">
        <div class="slider-container">
            <div class="slider-label">
                <span style="color:var(--accent-red)">Breaker</span>
                <span id="val-red">1.0x</span>
            </div>
            <input type="range" id="slider-red" min="100" max="800" value="400" step="10">
        </div>

        <div class="slider-container">
            <div class="slider-label">
                <span style="color:var(--accent-green)">Builder</span>
                <span id="val-green">1.0x</span>
            </div>
            <input type="range" id="slider-green" min="100" max="800" value="400" step="10">
        </div>

        <div class="slider-container">
            <div class="slider-label">
                <span style="color:var(--accent-blue)">Time</span>
                <span id="val-time">60s</span>
            </div>
            <input type="range" id="slider-time" min="10" max="120" value="60" step="5">
        </div>

        <div class="slider-container">
            <div class="slider-label">
                <span style="color:#e0e0e0">Chaos</span>
                <span id="val-chaos">0%</span>
            </div>
            <input type="range" id="slider-chaos" min="0" max="50" value="0" step="5">
        </div>
    </div>

    <div class="btn-group">
        <!-- Multi-Brick Toggle -->
        <label class="toggle-wrapper" title="Balls break/build multiple bricks at once">
            <input type="checkbox" id="check-multi" style="display:none;">
            <div class="toggle-switch"></div>
            <span>Multi</span>
        </label>

        <button class="icon-btn" id="btn-sound" title="Toggle Sound">
            <!-- SVG Speaker Icon -->
            <svg viewBox="0 0 24 24">
                <path d="M11 5L6 9H2v6h4l5 4V5z"/>
                <path id="sound-waves" d="M15.54 8.46a5 5 0 0 1 0 7.07M19.07 4.93a10 10 0 0 1 0 14.14" style="display:none;"/>
                <line id="sound-off" x1="1" y1="1" x2="23" y2="23" stroke="currentColor" stroke-width="2" />
            </svg>
        </button>

        <button class="action-btn" id="btn-reset">Restart</button>
        
        <button class="icon-btn" id="btn-menu" title="History">
            <!-- SVG Menu Icon -->
            <svg viewBox="0 0 24 24">
                <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
            </svg>
        </button>
    </div>
</header>

<!-- HERO GAME SECTION -->
<div id="hero-section">
    <div id="game-wrapper">
        <div id="timer-display">60</div>
        <canvas id="gameCanvas"></canvas>
        <!-- Overlay Result -->
        <div id="overlay-result">
            <h2 id="result-title" style="color:#fff; font-size:3rem; margin-bottom:10px;">GAME OVER</h2>
            <div id="result-desc" style="font-size:1.2rem; color:#aaa; margin-bottom:30px;">Result description here</div>
            <button class="action-btn" id="btn-play-again" style="background:var(--accent-blue); border:none; color:white; padding:12px 30px;">Play Again</button>
        </div>
    </div>
</div>

<!-- SEO / CONTENT SECTION -->
<article id="content-section">
    <div class="seo-header">
        <h2>Order vs. Chaos: The Simulation</h2>
        <p>Welcome to Make-or-Break, a digital playground that visualizes the eternal struggle between construction and destruction. This isn't just a game; it's a procedural art piece driven by your choices.</p>
    </div>

    <div class="seo-grid">
        <div class="info-card">
            <h3>How It Works</h3>
            <p>Two autonomous agents roam the grid. The <strong>Red Breaker</strong> seeks to destroy, turning active cells dark. The <strong>Green Builder</strong> seeks to repair, illuminating the void. You act as the god of this universe, controlling their speed, the flow of time, and the randomness (chaos) of their paths.</p>
        </div>

        <div class="info-card">
            <h3>New: Multi-Mode</h3>
            <p>Turn on "Multi" in the header to enable splash damage. In this mode, collisions impact not just one cell, but the entire surrounding cluster. This drastically speeds up the simulation and creates fascinating organic patterns on the grid.</p>
        </div>

        <!-- AdSense Unit -->
        <div class="full-width-card">
            <div class="ad-container">
                <!-- Google AdSense Code -->
                <ins class="adsbygoogle"
                     style="display:block"
                     data-ad-client="ca-pub-4315629123147124"
                     data-ad-slot="1234567890"
                     data-ad-format="auto"
                     data-full-width-responsive="true"></ins>
                <script>
                     (adsbygoogle = window.adsbygoogle || []).push({});
                </script>
                <span style="position:absolute; font-size:10px; opacity:0.5;">Advertisement</span>
            </div>
        </div>

        <div class="info-card full-width-card">
            <h3>The Philosophy</h3>
            <p>Notice how easier it is to break than to build? Or is it? By adjusting the sliders, you might find that a slow, methodical builder can outpace a frantic, chaotic breaker. This simulation is designed to be a "second monitor" experience—something to watch while you think, helping you find your own balance.</p>
        </div>

        <div class="info-card">
            <h3>FAQ: Winning</h3>
            <p>The timer at the top counts down the entropy war. If the grid is more than 50% Green (Active) when time runs out, Order prevails. If Red dominates, Chaos wins.</p>
        </div>
        
        <div class="info-card">
            <h3>FAQ: Controls</h3>
            <p>Use the <strong>Chaos</strong> slider to introduce jitter and unpredictability. Use the <strong>Speed</strong> sliders to handicap or boost specific agents.</p>
        </div>
    </div>
</article>

<!-- SIDE MENU -->
<div id="side-menu">
    <div class="menu-header">
        <h3>Match History</h3>
        <button class="icon-btn" id="btn-close-menu">✕</button>
    </div>
    <div class="menu-content">
        <button class="action-btn" id="btn-clear-history" style="width:100%; margin-bottom:15px; background:#2a1a1a; color:#ff5c5c; border-color:#522;">Clear History</button>
        <div id="history-list"></div>
    </div>
</div>

<!-- JAVASCRIPT -->
<script>
/** * AUDIO ENGINE
 * Simple oscillator-based audio for feedback
 */
const AudioEngine = {
    ctx: null,
    enabled: false,
    
    init() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
    },

    toggle() {
        this.enabled = !this.enabled;
        if (this.enabled && !this.ctx) this.init();
        if (this.enabled && this.ctx.state === 'suspended') this.ctx.resume();
        return this.enabled;
    },

    playTone(heightPct, type) {
        if (!this.enabled || !this.ctx) return;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        // Sound Profile: Breaker is lower/sawtooth, Builder is higher/sine
        const baseFreq = type === 'breaker' ? 100 : 300;
        const freq = baseFreq + (heightPct * 500); 
        
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.type = type === 'breaker' ? 'sawtooth' : 'sine';
        
        // Quick decay envelope
        const vol = type === 'breaker' ? 0.04 : 0.03;
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
    }
};

/**
 * GAME ENGINE
 */
const LOGICAL_WIDTH = 800;
const LOGICAL_HEIGHT = 600;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d', { alpha: false });

// DOM Elements
const sliderRed = document.getElementById('slider-red');
const sliderGreen = document.getElementById('slider-green');
const sliderTime = document.getElementById('slider-time');
const sliderChaos = document.getElementById('slider-chaos');
const checkMulti = document.getElementById('check-multi');

const labelRed = document.getElementById('val-red');
const labelGreen = document.getElementById('val-green');
const labelTime = document.getElementById('val-time');
const labelChaos = document.getElementById('val-chaos');
const timerDisplay = document.getElementById('timer-display');
const overlayResult = document.getElementById('overlay-result');
const resultTitle = document.getElementById('result-title');
const resultDesc = document.getElementById('result-desc');

// State
const state = {
    running: true,
    gameOver: false,
    timeLeft: 60,
    lastFrameTime: 0
};

let balls = [];
let bricks = [];
let rows = 14;
let cols = 20;
let brickW = 0;
let brickH = 18;
let brickPad = 5;

/**
 * INITIALIZATION
 */
function init() {
    resize();
    resetSimulation();
    requestAnimationFrame(gameLoop);
}

function resize() {
    const wrapper = document.getElementById('game-wrapper');
    const aspect = LOGICAL_WIDTH / LOGICAL_HEIGHT;
    
    let w = wrapper.clientWidth;
    let h = wrapper.clientHeight;
    
    // Fit within container maintaining aspect ratio
    if (w / h > aspect) w = h * aspect;
    else h = w / aspect;

    // Set canvas display size
    canvas.style.width = `${w}px`;
    canvas.style.height = `${h}px`;
    
    // Set actual resolution
    const dpr = window.devicePixelRatio || 1;
    canvas.width = w * dpr;
    canvas.height = h * dpr;
    
    // Normalize coordinate system
    ctx.scale(dpr * (w/LOGICAL_WIDTH), dpr * (h/LOGICAL_HEIGHT));
}

function resetSimulation() {
    state.gameOver = false;
    state.running = true;
    state.timeLeft = parseInt(sliderTime.value);
    timerDisplay.innerText = state.timeLeft;
    overlayResult.style.display = 'none';

    initBricks();
    initBalls();
}

function initBricks() {
    bricks = [];
    brickW = (LOGICAL_WIDTH - (brickPad * (cols + 1))) / cols;
    const startY = 80; // Leave room for timer

    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            // 30% Active start rate
            const active = Math.random() < 0.3; 
            bricks.push({
                r: r, c: c, // Grid coords for neighbor lookup
                x: brickPad + c * (brickW + brickPad),
                y: startY + r * (brickH + brickPad),
                w: brickW, h: brickH,
                active: active
            });
        }
    }
}

function initBalls() {
    balls = [];
    balls.push(createBall(LOGICAL_WIDTH*0.3, LOGICAL_HEIGHT - 100, '#ff5c5c', 'breaker'));
    balls.push(createBall(LOGICAL_WIDTH*0.7, LOGICAL_HEIGHT - 100, '#4dff88', 'builder'));
}

function createBall(x, y, color, type) {
    const angle = Math.random() * Math.PI * 2;
    const initialSpeed = type === 'breaker' ? parseInt(sliderRed.value) : parseInt(sliderGreen.value);
    return {
        x: x, y: y, r: 10,
        vx: Math.cos(angle) * initialSpeed,
        vy: Math.sin(angle) * initialSpeed,
        color: color,
        type: type, 
        trail: [] 
    };
}

/**
 * PHYSICS LOOP
 */
function gameLoop(timestamp) {
    if (!state.lastFrameTime) state.lastFrameTime = timestamp;
    const dt = (timestamp - state.lastFrameTime) / 1000;
    state.lastFrameTime = timestamp;

    if (state.running && !state.gameOver) {
        update(Math.min(dt, 0.1)); // Cap dt to prevent skipping
    }
    
    draw();
    requestAnimationFrame(gameLoop);
}

function update(dt) {
    // Timer
    state.timeLeft -= dt;
    timerDisplay.innerText = Math.ceil(state.timeLeft);
    if (state.timeLeft <= 0) {
        state.timeLeft = 0;
        endGame();
    }

    // Update UI Labels
    const redSpeed = parseInt(sliderRed.value);
    const greenSpeed = parseInt(sliderGreen.value);
    const chaosVal = parseInt(sliderChaos.value);
    
    labelRed.innerText = (redSpeed/400).toFixed(1) + 'x';
    labelGreen.innerText = (greenSpeed/400).toFixed(1) + 'x';
    labelTime.innerText = parseInt(sliderTime.value) + 's';
    labelChaos.innerText = chaosVal + '%';

    // Ball Physics
    balls.forEach(b => {
        // Speed Governance
        const targetSpeed = b.type === 'breaker' ? redSpeed : greenSpeed;
        const currentV = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
        if (Math.abs(currentV - targetSpeed) > 1) {
            const scale = targetSpeed / currentV;
            b.vx *= scale;
            b.vy *= scale;
        }

        // Chaos (Random Jitter)
        if (chaosVal > 0 && Math.random() < 0.05) {
            b.vx += (Math.random() - 0.5) * chaosVal * 15;
            b.vy += (Math.random() - 0.5) * chaosVal * 15;
        }

        // Move
        b.x += b.vx * dt;
        b.y += b.vy * dt;

        // Trail Update
        b.trail.unshift({x: b.x, y: b.y, age: 0});
        if (b.trail.length > 25) b.trail.pop(); // Slightly longer trail for the jet look
        b.trail.forEach(t => t.age += dt);

        // Wall Collision
        if (b.x - b.r < 0) { b.x = b.r; b.vx *= -1; }
        if (b.x + b.r > LOGICAL_WIDTH) { b.x = LOGICAL_WIDTH - b.r; b.vx *= -1; }
        if (b.y - b.r < 0) { b.y = b.r; b.vy *= -1; }
        if (b.y + b.r > LOGICAL_HEIGHT) { b.y = LOGICAL_HEIGHT - b.r; b.vy *= -1; }

        // Brick Interaction
        checkBrickCollision(b);
    });
}

function checkBrickCollision(ball) {
    // Optimization: Only check if ball is in brick area
    if (ball.y < 50 || ball.y > LOGICAL_HEIGHT - 50) return;

    for (let i = 0; i < bricks.length; i++) {
        let brick = bricks[i];
        
        // Logical check: Can this ball affect this brick?
        const canInteract = (brick.active && ball.type === 'breaker') || (!brick.active && ball.type === 'builder');

        if (canInteract && rectCircleIntersect(brick, ball)) {
            // Physics Bounce - ONLY IF NOT in Multi Mode
            if (!checkMulti.checked) {
                resolveCollision(ball, brick);
            }
            
            // Gameplay Effect
            if (checkMulti.checked) {
                // Multi-Mode: Affect neighbors + self
                triggerBrick(brick, ball.type); // Center
                // Find neighbors
                getNeighbors(brick).forEach(n => triggerBrick(n, ball.type));
            } else {
                // Single Mode
                triggerBrick(brick, ball.type);
            }
            
            // Sound
            const heightPct = 1 - (brick.y / LOGICAL_HEIGHT);
            AudioEngine.playTone(heightPct, ball.type);

            break; // Only hit one cluster per frame
        }
    }
}

function triggerBrick(brick, type) {
    if (type === 'breaker') brick.active = false;
    else brick.active = true;
}

function getNeighbors(brick) {
    // Simple neighbor lookup in grid
    return bricks.filter(b => {
        const dr = Math.abs(b.r - brick.r);
        const dc = Math.abs(b.c - brick.c);
        return (dr <= 1 && dc <= 1) && !(dr === 0 && dc === 0);
    });
}

function resolveCollision(b, rect) {
    const dx = b.x - (rect.x + rect.w/2);
    const dy = b.y - (rect.y + rect.h/2);
    const w = rect.w/2 + b.r;
    const h = rect.h/2 + b.r;
    
    const crossWidth = w * dy;
    const crossHeight = h * dx;
    
    if (Math.abs(dx) <= w && Math.abs(dy) <= h) {
        if (crossWidth > crossHeight) {
            if (crossWidth > -crossHeight) b.vy *= -1; 
            else b.vx *= -1; 
        } else {
            if (crossWidth > -crossHeight) b.vx *= -1; 
            else b.vy *= -1; 
        }
    }
}

function rectCircleIntersect(rect, circle) {
    const distX = Math.abs(circle.x - rect.x - rect.w / 2);
    const distY = Math.abs(circle.y - rect.y - rect.h / 2);

    if (distX > (rect.w / 2 + circle.r)) return false;
    if (distY > (rect.h / 2 + circle.r)) return false;

    if (distX <= (rect.w / 2)) return true;
    if (distY <= (rect.h / 2)) return true;

    const dx = distX - rect.w / 2;
    const dy = distY - rect.h / 2;
    return (dx * dx + dy * dy <= (circle.r * circle.r));
}

function endGame() {
    state.gameOver = true;
    const active = bricks.filter(b => b.active).length;
    const total = bricks.length;
    const greenPct = (active / total * 100).toFixed(1);
    const redPct = ((total - active) / total * 100).toFixed(1);
    const builderWon = active > (total / 2);

    // Save History
    saveHistory({
        winner: builderWon ? 'Builder' : 'Breaker',
        green: greenPct,
        red: redPct,
        date: new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})
    });

    // UI Update
    if (builderWon) {
        resultTitle.innerHTML = `<span style="color:var(--accent-green)">Builder Wins!</span>`;
        resultDesc.innerHTML = `Order restored. ${greenPct}% of the grid is active.`;
    } else {
        resultTitle.innerHTML = `<span style="color:var(--accent-red)">Breaker Wins!</span>`;
        resultDesc.innerHTML = `Entropy reigns. Only ${greenPct}% of the grid survived.`;
    }
    overlayResult.style.display = 'flex';
}

/**
 * RENDERING
 */
function draw() {
    // Clear & Background
    ctx.fillStyle = '#0b0d16';
    ctx.fillRect(0, 0, LOGICAL_WIDTH, LOGICAL_HEIGHT);

    // Get Ball Positions for Glow Math
    const redBall = balls.find(b => b.type === 'breaker');
    const greenBall = balls.find(b => b.type === 'builder');

    // Draw Bricks
    bricks.forEach(b => {
        // Calculate distance to balls for dynamic lighting
        const distRed = Math.hypot(b.x + b.w/2 - redBall.x, b.y + b.h/2 - redBall.y);
        const distGreen = Math.hypot(b.x + b.w/2 - greenBall.x, b.y + b.h/2 - greenBall.y);
        const threshold = 120;

        if (b.active) {
            // Alive Brick
            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 0;
            
            // Red Threat Glow
            if (distRed < threshold) {
                const alpha = 1 - (distRed / threshold);
                ctx.shadowColor = '#ff5c5c';
                ctx.shadowBlur = 20 * alpha;
                ctx.fillStyle = `rgb(255, ${200 * (1-alpha)}, ${200 * (1-alpha)})`;
            }
            ctx.fillRect(b.x, b.y, b.w, b.h);
        } else {
            // Dead Brick (Outline)
            if (distGreen < threshold) {
                // Green Opportunity Glow
                const alpha = 1 - (distGreen / threshold);
                ctx.strokeStyle = `rgba(77, 255, 136, ${alpha})`;
                ctx.shadowColor = '#4dff88';
                ctx.shadowBlur = 15 * alpha;
                ctx.lineWidth = 2;
                ctx.strokeRect(b.x, b.y, b.w, b.h);
            } else {
                ctx.strokeStyle = '#1a1d2e';
                ctx.shadowBlur = 0;
                ctx.lineWidth = 1;
                ctx.strokeRect(b.x + 2, b.y + 2, b.w - 4, b.h - 4);
            }
        }
        ctx.shadowBlur = 0;
    });

    // Draw Balls
    balls.forEach(b => {
        // NEW TRAIL RENDERING (Jet-like)
        if (b.trail.length > 1) {
            // Draw many small circles or line segments with decreasing opacity/width
            // We iterate from 0 (head) to end (tail)
            for(let i=0; i<b.trail.length-1; i++) {
                const pt = b.trail[i];
                const next = b.trail[i+1];
                
                // Ratio goes from 0 (head) to 1 (tail)
                const ratio = i / b.trail.length;
                
                ctx.beginPath();
                ctx.moveTo(pt.x, pt.y);
                ctx.lineTo(next.x, next.y);
                
                ctx.strokeStyle = b.color;
                // Jet Effect: Width shrinks rapidly, Opacity fades
                ctx.lineWidth = b.r * (1 - ratio); 
                ctx.lineCap = 'round';
                
                // Add a glow to the start of the trail
                if (i < 5) {
                    ctx.shadowColor = b.color;
                    ctx.shadowBlur = 10;
                } else {
                    ctx.shadowBlur = 0;
                }

                // Opacity fades out
                ctx.globalAlpha = (1 - ratio) * 0.6; 
                ctx.stroke();
            }
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = 0;
        }

        // Body
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
        ctx.fillStyle = b.color;
        ctx.shadowColor = b.color;
        ctx.shadowBlur = 20;
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Highlight
        ctx.beginPath();
        ctx.arc(b.x - 3, b.y - 3, b.r/3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.8)';
        ctx.fill();
    });

    // Progress Bar (Bottom)
    drawProgressBar();
}

function drawProgressBar() {
    const barH = 6;
    const total = bricks.length;
    const active = bricks.filter(b => b.active).length;
    const greenW = (active / total) * LOGICAL_WIDTH;

    // Red Base
    ctx.fillStyle = '#ff5c5c';
    ctx.fillRect(0, LOGICAL_HEIGHT - barH, LOGICAL_WIDTH, barH);
    
    // Green Overlay
    ctx.fillStyle = '#4dff88';
    ctx.shadowColor = '#4dff88';
    ctx.shadowBlur = 10;
    ctx.fillRect(0, LOGICAL_HEIGHT - barH, greenW, barH);
    ctx.shadowBlur = 0;
}

/**
 * PERSISTENCE
 */
const STORAGE_KEY = 'mob_history_v1';

function saveHistory(entry) {
    let hist = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
    hist.unshift(entry);
    if (hist.length > 20) hist.pop();
    localStorage.setItem(STORAGE_KEY, JSON.stringify(hist));
    renderHistory();
}

function renderHistory() {
    const list = document.getElementById('history-list');
    const hist = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
    
    if (hist.length === 0) {
        list.innerHTML = '<div style="color:#666; text-align:center;">No match history.</div>';
        return;
    }

    list.innerHTML = hist.map(h => {
        const winClass = h.winner === 'Builder' ? 'win-green' : 'win-red';
        return `
        <div class="score-entry ${winClass}">
            <span style="color:#aaa">${h.date}</span>
            <span style="font-weight:bold; color:${h.winner==='Builder'?'var(--accent-green)':'var(--accent-red)'}">
                ${h.winner} (${h.winner==='Builder'?h.green:h.red}%)
            </span>
        </div>`;
    }).join('');
}

document.getElementById('btn-clear-history').onclick = () => {
    localStorage.removeItem(STORAGE_KEY);
    renderHistory();
};

/**
 * UI BINDINGS
 */
document.getElementById('btn-reset').onclick = resetSimulation;
document.getElementById('btn-play-again').onclick = resetSimulation;

// Sound Toggle
const btnSound = document.getElementById('btn-sound');
const soundOn = document.getElementById('sound-waves');
const soundOff = document.getElementById('sound-off');

btnSound.onclick = () => {
    const enabled = AudioEngine.toggle();
    btnSound.classList.toggle('active');
    soundOn.style.display = enabled ? 'block' : 'none';
    soundOff.style.display = enabled ? 'none' : 'block';
};

// Menu Toggle
const menu = document.getElementById('side-menu');
document.getElementById('btn-menu').onclick = () => menu.classList.add('open');
document.getElementById('btn-close-menu').onclick = () => menu.classList.remove('open');

// Resize Listener
window.addEventListener('resize', resize);

// Init
renderHistory();
init();
</script>

</body>
</html>
